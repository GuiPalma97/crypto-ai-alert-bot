# -*- coding: utf-8 -*-
"""Crypto_Bot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mA556gjzAJ01Ldt_IgihrcqBeUOtilT5
"""

# Instala√ß√£o das libs no Colab (execute 1 vez)
!apt-get update -qq
!apt install -y chromium-chromedriver
!cp /usr/lib/chromium-browser/chromedriver /usr/bin
!pip install requests beautifulsoup4 vaderSentiment matplotlib schedule twilio scikit-learn yfinance pandas
!pip install -q python-telegram-bot --upgrade
!pip install pandas numpy matplotlib requests vaderSentiment scikit-learn tensorflow

import requests
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
from sklearn.cluster import KMeans
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from datetime import datetime
import io
import time

# ========== CONFIGURA√á√ïES ==========
CRIPTO_LISTA = ['bitcoin', 'ethereum', 'solana', 'aave', 'lido-dao', 'pendle']
ANALISADOR = SentimentIntensityAnalyzer()

# TELEGRAM - Substitua pelos seus dados:
NEWSAPI_KEY = "bfca953572834ef786d29a2869b07275"
TELEGRAM_TOKEN = "8123262775:AAHEv43aS9dK8jXSjINqhDXbqxlHAfn4aTw"
TELEGRAM_CHAT_ID = "7657570667"
# ========== FUN√á√ïES ==========

def enviar_telegram(mensagem, imagem=None):
    url_base = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}"
    if imagem:
        files = {'photo': imagem}
        data = {'chat_id': TELEGRAM_CHAT_ID, 'caption': mensagem}
        requests.post(f"{url_base}/sendPhoto", data=data, files=files)
    else:
        data = {'chat_id': TELEGRAM_CHAT_ID, 'text': mensagem}
        requests.post(f"{url_base}/sendMessage", data=data)

def buscar_noticias(cripto):
    try:
        url = f"https://news.google.com/rss/search?q={cripto}+criptomoeda&hl=pt-BR&gl=BR&ceid=BR:pt-419"
        response = requests.get(url)
        noticias = pd.read_xml(response.text)
        return noticias['title'].tolist()[:10]
    except:
        return []

def analisar_sentimento(noticias):
    if not noticias: return 0
    scores = [ANALISADOR.polarity_scores(n)['compound'] for n in noticias]
    return np.mean(scores)

def obter_historico(cripto):
    url = f"https://api.coingecko.com/api/v3/coins/{cripto}/market_chart?vs_currency=usd&days=90"
    response = requests.get(url).json()
    if 'prices' not in response: return pd.DataFrame()
    df = pd.DataFrame(response['prices'], columns=['timestamp', 'price'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    return df

def calcular_rsi(df, periodo=14):
    delta = df['price'].diff()
    ganho = delta.clip(lower=0)
    perda = -delta.clip(upper=0)
    media_ganho = ganho.rolling(periodo).mean()
    media_perda = perda.rolling(periodo).mean()
    rs = media_ganho / media_perda
    rsi = 100 - (100 / (1 + rs))
    return rsi

def calcular_bollinger(df, periodo=20):
    media = df['price'].rolling(window=periodo).mean()
    desvio = df['price'].rolling(window=periodo).std()
    return media + 2 * desvio, media - 2 * desvio

def treinar_lstm(df):
    dados = df['price'].values.reshape(-1,1)
    scaler = MinMaxScaler()
    dados_norm = scaler.fit_transform(dados)
    X, y = [], []
    for i in range(10, len(dados_norm)):
        X.append(dados_norm[i-10:i])
        y.append(dados_norm[i])
    X, y = np.array(X), np.array(y)
    model = Sequential([LSTM(50, input_shape=(10,1)), Dense(1)])
    model.compile(optimizer='adam', loss='mse')
    model.fit(X, y, epochs=10, verbose=0)
    pred = model.predict(dados_norm[-10:].reshape(1,10,1), verbose=0)
    return scaler.inverse_transform(pred)[0][0]

def clustering(df):
    dados = df['price'].values.reshape(-1,1)
    kmeans = KMeans(n_clusters=3, random_state=42).fit(dados)
    return kmeans.labels_[-1]

def gerar_grafico(df, nome):
    plt.figure(figsize=(10,5))
    plt.plot(df['timestamp'], df['price'], label='Pre√ßo', color='blue')
    plt.title(f'{nome.upper()} - Hist√≥rico de Pre√ßos')
    plt.xlabel('Data')
    plt.ylabel('USD')
    plt.legend()
    plt.grid()
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    return buf

def analisar_cripto(cripto):
    nome = cripto.upper()
    print(f"üîç Analisando: {nome}")
    df = obter_historico(cripto)

    if df.empty or len(df) < 30:
        enviar_telegram(f"{nome}: Dados insuficientes para an√°lise.")
        return

    noticias = buscar_noticias(cripto)
    sentimento = analisar_sentimento(noticias)
    preco = df['price'].iloc[-1]
    rsi = calcular_rsi(df).iloc[-1]
    sup, inf = calcular_bollinger(df)
    pred = treinar_lstm(df)
    cluster = clustering(df)

    rsi_msg = "Neutro"
    if rsi > 70: rsi_msg = "Sobrecompra (Poss√≠vel Venda)"
    elif rsi < 30: rsi_msg = "Sobrevenda (Poss√≠vel Compra)"

    bb_status = "dentro"
    if preco > sup.iloc[-1]: bb_status = "acima da banda superior"
    elif preco < inf.iloc[-1]: bb_status = "abaixo da banda inferior"

    cluster_msg = {
        0: "Acumula√ß√£o",
        1: "Alta Volatilidade",
        2: "Tend√™ncia de Alta"
    }.get(cluster, "Desconhecido")

    mensagem = (
        f"üìä {nome} - An√°lise Completa\n"
        f"üí∞ Pre√ßo Atual: ${preco:,.2f}\n"
        f"üß† Sentimento: {'Positivo' if sentimento > 0 else 'Negativo' if sentimento < 0 else 'Neutro'} ({sentimento:.2f})\n"
        f"üìà RSI: {rsi:.2f} ‚Üí {rsi_msg}\n"
        f"üìâ Bandas de Bollinger: Pre√ßo est√° {bb_status}\n"
        f"ü§ñ Previs√£o LSTM: ${pred:,.2f}\n"
        f"üîé Clustering: {cluster_msg}\n"
        f"üóìÔ∏è {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}"
    )

    imagem = gerar_grafico(df, nome)
    enviar_telegram(mensagem, imagem)

# ========== EXECU√á√ÉO ==========

for cripto in CRIPTO_LISTA:
    try:
        analisar_cripto(cripto)
        time.sleep(5)
    except Exception as e:
        enviar_telegram(f"Erro ao analisar {cripto}: {e}")